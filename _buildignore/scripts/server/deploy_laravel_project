#!/usr/bin/env bash

# Description

###############################################################################
# Constants and Defaults
###############################################################################

# Required by boilerplate
readonly _script_version="1.0.0"

readonly __web_root="/var/www"
readonly __nginx_root_directories="/etc/nginx/includes/root_directories"

###############################################################################
# Help
###############################################################################

function _usage() {
  cat << EOF
Usage: ${__file:?} [OPTIONS] PROJECT_NAME ENVIRONMENT_NAME BUILD_NUMBER PHP_VERSION SUCCESSFUL_RELEASES_TO_KEEP
  
Options:
  ${_usage_standard_options}
EOF
}

###############################################################################
# Script-Specific Cleanup
###############################################################################

function script_specific_cleanup() {
  :
}

###############################################################################
# Boilerplate Constants and Defaults
###############################################################################

__boilerplate_version="1.0.0"
__file="$(basename "${0}")"
readonly __boilerplate_version __file

###############################################################################
# Cleanup
###############################################################################

# Usage: _general_cleanup
# Triggered after execution when success or error. Call the script-specific
# cleanup then stop the timeout process if enabled
function _general_cleanup() {
  script_specific_cleanup
  _stop_timeout_process
}

###############################################################################
# Strict Mode
###############################################################################

# Usage: _enable_strict_mode
function _enable_strict_mode() {
  set -o errexit  # set -e
  set -o nounset  # set -u
  set -o pipefail
  set -o errtrace # set -E
  IFS=$'\n\t'
  trap 'echo "Error occurred on line $LINENO. Exit code: $?" >&2' ERR
  trap _general_cleanup EXIT
}

# Usage: _disable_strict_mode
function _disable_strict_mode() {
  set +o errexit
  set +o nounset
  set +o pipefail
  set +o errtrace
  IFS=$' \t\n'
  trap - ERR EXIT
}

###############################################################################
# Validate Environment
###############################################################################

# Usage: _validate_commands <commands>
# Example: _validate_commands php git
# Check important commands are available
function _validate_commands() {
  local __cmd
  for __cmd in "${@}"; do
    if ! command -v "${__cmd:?}" &>/dev/null; then
      _exit_1 echo "'${__cmd}' command not found."
    fi
  done
}

###############################################################################
# Messages
###############################################################################

# Usage: _exit_1 <command>
# Exit with status 1 after executing the specified command with output
# redirected to standard error. The command is expected to print a message
# and should typically be either `echo`, `printf`, or `cat`.
function _exit_1() {
  {
    printf "%s " "$(tput setaf 1)!$(tput sgr0)"
    "${@}"
  } 1>&2
  exit 1
}

# Usage: _warn <command>
# Print the specified command with output redirected to standard error.
# The command is expected to print a message and should typically be either
# `echo`, `printf`, or `cat`.
function _warn() {
  {
    printf "%s " "$(tput setaf 1)!$(tput sgr0)"
    "${@}"
  } 1>&2
}

# Usage: _verbose <command>
# Print the specified command with output redirected to standard error.
# The command is expected to print a message and should typically be either
# `echo`, `printf`, or `cat`.
function _verbose() {
  if ((${__verbose_option:-0})); then
    {
      "${@}"
    } 1>&2
  fi
}

# Usage: _debug <command> <options>...
# Execute a command and print to standard error. The command is expected to
# print a message and should typically be either `echo`, `printf`, or `cat`
__debug_counter=0
function _debug() {
  if ((${__debug_option:-0})); then
    __debug_counter=$((__debug_counter+1))
    {
      # Prefix debug message with "bug (U+1F41B)"
      printf "ðŸ›  %s " "${__debug_counter}"
      "${@}"
      printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\\n"
    } 1>&2
  fi
}

###############################################################################
# Timeout
###############################################################################

# Usage: _start_timeout_process <timeout_duration>
# Kill the script process after a given number of seconds
function _start_timeout_process() {
  local timeout_duration="${1:?}"

  if ((timeout_duration)); then
    {
      sleep "${timeout_duration}"
      echo "Script timed out after ${timeout_duration} seconds." >&2
      kill -SIGTERM "$$"
    } &
    __timeout_pid=$!
  fi
}

# Usage: _stop_timeout_process
function _stop_timeout_process() {
  if ((${__timeout_pid:--1} > 0)); then
    kill "${__timeout_pid}" 2>/dev/null || true
    wait "${__timeout_pid}" 2>/dev/null || true
    __timeout_pid=-1
  fi
}

###############################################################################
# Input Validation Functions
###############################################################################

# Usage: is_unsigned_integer <argument-to-check>
function is_unsigned_integer() {
  if [[ "${1}" =~ ^[0-9]+$ ]]; then
    return 0
  fi
  return 1
}

# Usage: is_unsigned_decimal <argument-to-check>
function is_unsigned_decimal() {
  if [[ "${1}" =~ ^[0-9]+\.[0-9]+$ ]]; then
    return 0
  fi
  return 1
}

# Usage: is_semantic_version <argument-to-check>
function is_semantic_version() {
  if [[ "${1}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    return 0
  fi
  return 1
}

# Usage: is_alphanumeric_underscore_dot_dash <argument-to-check>
function is_alphanumeric_underscore_dot_dash() {
  if [[ "${1}" =~ ^[a-zA-Z0-9_.-]+$ ]]; then
    return 0
  fi
  return 1
}

###############################################################################
# Process Options
###############################################################################

# Usage: _split_short_options <short_option>
# Split grouped short options and split off any trailing value
# -abc=123  =>  -a -b -c 123
function _split_short_options() {
  local __short_option="${1:?}"
  local __index __character

  # Split off each letter into a separate short option
  # Skip the first character (-)
  for ((__index=1; __index < ${#__short_option}; __index++)); do
    __character="${__short_option:$__index:1}"

    # TODO(ianflanagan): consider checking that option characters are alphanumeric

    # If the final short option has a trailing value connected by =
    # then split it and stop parsing short options
    if [[ "${__character}" == "=" ]]; then
      printf "%s\\n" "${__short_option:$__index+1}"
      break
    fi

    printf "%s\\n" "-${__character}"
  done
}

# Usage: _split_long_options <long_option>
# If a long option has a trailing value (connected by =), then split them
# --option=123  =>  --option 123
function _split_long_options() {
  local __long_option="${1:?}"

  if [[ "$__long_option" == --*=* ]]; then
    printf "%s\\n" "${__long_option%%=*}" # the string before the first equals sign
    printf "%s\\n" "${__long_option#*=}"  # the string after the first equals sign
  else
    printf "%s\\n" "${__long_option}"
  fi
}

# Usage: _split_options <arguments>
# Pass short options to `_split_short_options` and pass long options to
# `_split_long_options`
function _split_options() {
  local __processed_option __argument
  _args=()

  while ((${#@})); do
    __argument="${1:?}" # error on empty string arguments

    # Send short options to `_split_short_options`
    if [[ "${__argument}" =~ ^-[^-] ]]; then

      # Use mapfile to read the output into the _args array
      # https://www.shellcheck.net/wiki/SC2207
      mapfile -t __processed_option < <(_split_short_options "${__argument}")
      _args+=("${__processed_option[@]}")

    # Send long options to `_split_long_options`
    elif [[ "${__argument}" =~ ^--[^=]+ ]]; then
      mapfile -t __processed_option < <(_split_long_options "${__argument}")
      _args+=("${__processed_option[@]}")

    # Otherwise leave the argument as it is
    else
      _args+=("${__argument}")
    fi
    shift
  done
}

###############################################################################
# Option-Parsing Functions
###############################################################################

# Usage: __get_option_value <option> <value>
# Check that the argument after the option is not empty
function __get_option_value() {
  local __option="${1:?}" 
  local __value="${2:-}"

  if [[ -n "${__value}" ]]; then
    printf "%s\\n" "${__value}"
  else
    _exit_1 printf "%s requires an argument.\\n" "${__option}"
  fi
}

# Text added to script-specific help/usage function
readonly _usage_standard_options="-h, --help      Display this help message
  -V, --version   Show version information
  -v, --verbose   Enable verbose output
  --debug         Enable debug output
  --endopts       Stop reading options and arguments
  --timeout <0>   Stop execution after a given number of seconds"

# Usage: _parse_common_options <arguments>
# Parse the arguments the boilerplate's options common to all script
function _parse_common_options() {
  _args=()

  while ((${#@})); do
    local __argument="${1:?}" # error on empty string arguments
    local __value="${2:-}"

    # Make sure to replace common options with empty strings to avoid script
    # specific options being incorrectly paired with following arguments
    case "${__argument}" in
      # Options that don't require values
      -h|--help)
        # _help_option=1
        # _args+=("")
        _usage
        exit 0
        ;;
      -V|--version)
        echo "${__file:?} version: ${_script_version:?}, with boilerplate version: ${__boilerplate_version:?}"
        exit 0
        ;;
      -v|--verbose)
        __verbose_option=1
        _args+=("")
        ;;
      --debug)
        __debug_option=1
        _args+=("")
        ;;
      --endopts)
        break # Terminate option parsing
        ;;

      # Options that require values
      --timeout)
        local timeout_duration
        timeout_duration="$(__get_option_value "${__argument}" "${__value}")"

        if ! is_unsigned_integer "${timeout_duration}"; then
          _exit_1 echo "--timeout must be an unsigned integer. '${timeout_duration}' given" >&2
        fi

        _start_timeout_process "${timeout_duration}"

        _args+=("")
        shift
        ;;

      # Pass remaining argument to `_parse_script_specific_options`
      *)
        _args+=("${__argument}")
        ;;
    esac
    shift
  done
}

###############################################################################
# Script-Specific Options
###############################################################################

function _parse_script_specific_options() {
  _args=()

  while ((${#@})); do
    local __argument="${1:-}"
    local __value="${2:-}"

    if [[ -z ${__argument} ]]; then
      shift
      continue
    fi

    case "${__argument}" in
    -*)
      _exit_1 echo "Invalid option: ${__argument}"
      ;;
    *)
      _args+=("${__argument}")
      ;;
    esac
    shift
  done
}

###############################################################################
# Arguments
###############################################################################

function _validate_positional_arguments() {
  if [[ "${#@}" -ne 5 ]]; then
    _usage
    _exit_1 echo "Needs 5 arguments. ${#@} given" >&2
  fi

  readonly __project_name=${1:?}
  readonly environment_name=${2:?}
  readonly build_number=${3:?}
  readonly php_version=${4:?}
  readonly successful_releases_to_keep=${5:?}

  if ! is_alphanumeric_underscore_dot_dash "${__project_name}"; then
      usage
      _exit_1 echo "PROJECT_NAME must be alphanumeric or _ . -"
  fi

  # Check project group exists
  if ! getent group "${__project_name}" &>/dev/null; then
    _exit_1 echo "'${__project_name}' group does not exist"
  fi

  if ! is_alphanumeric_underscore_dot_dash "${environment_name}"; then
      usage
      _exit_1 echo "ENVIRONMENT_NAME must be alphanumeric or _ . -"
  fi

  if ! is_unsigned_integer "${build_number}"; then
      usage
      _exit_1 echo "BUILD_NUMBER must be an unsigned integer"
  fi

  if ! is_unsigned_decimal "${php_version}"; then
      usage
      _exit_1 echo "PHP_VERSION must take the form: *.*"
  fi

  if ! is_unsigned_integer "${successful_releases_to_keep}"; then
      usage
      _exit_1 echo "SUCCESSFUL_RELEASES_TO_KEEP must be a positive integer"
  fi
}

###############################################################################
# Functions
###############################################################################

# Usage: create_backup <absolute-path>
# Create backup of file, directory, or symlink
function create_backup() {
  cp --force --recursive --preserve=mode,ownership --no-dereference "${1:?}" "${1}.bak"
}

# Usage: restore_from_backup <absolute-path>
# Move backup file, directory, or symlink to overwrite original
function restore_from_backup() {
  if ! [[ -e "${1:?}.bak" ]]; then
    _exit_1 "Backup missing: ${1}.bak"
  fi
  rm --force --recursive "${1}"
  mv --force --no-target-directory "${1}.bak" "${1}"
}

# Usage: purge_backup <absolute-path>
# Delete backup file, directory, or symlink
function purge_backup() {
  rm --force --recursive "${1}.bak"
}

# Usage: prepare
# Create variables, set permissions, and run checks to prepare to switch build
function set_global_variables() {
  readonly project_environment_root="${__web_root}/${__project_name}/${environment_name}"
  readonly releases_root="${project_environment_root}/releases"
  readonly build_root="${releases_root}/${build_number}"
  readonly env_file_path="${project_environment_root}/deploy/.env"
  readonly log_file_path="${build_root}/storage/logs/laravel.log"
  readonly sqlite_file_path="${build_root}/database/database.sqlite"
  readonly nginx_reference_file_path="${__nginx_root_directories}/${__project_name}-${environment_name}"
  readonly current_symlink="${project_environment_root}/current"
  readonly php_fpm="php${php_version}-fpm"

  # Check build directory exists
  if [[ ! -d "${build_root}" ]]; then
    _exit_1 echo "${build_root} directory does not exist"
  fi
}

# Usage: set_release_permissions
# TODO(ianflanagan): consider setting these on jenkins and rsync with
# '--perms' '--owner' '--group' etc
# Research the need to align UID/GID etc.
function set_release_permissions() {
  echo "Setting permissions"
  chown -R "www-data:${__project_name}" "${build_root}"
  chmod -R 0440 "${build_root}"
  find "${build_root}" -type d -exec chmod 0550 {} +
  chmod -R 0770 "${build_root}/storage" "${build_root}/bootstrap/cache"

  # laravel.log also needs group write access (for php artisan commands)
  if [[ -f "${log_file_path}" ]]; then
    chmod 0660 "${log_file_path}"
  else
    install -o www-data -g "${__project_name}" -m 0660 /dev/null "${log_file_path}"
  fi

  # ./database and ./database/database.sqlite also need group write access (for php artisan commands)
  chmod 0770 "${build_root}/database"
  if [[ -f "${sqlite_file_path}" ]]; then
    chmod 0660 "${sqlite_file_path}"
  else
    install -o www-data -g "${__project_name}" -m 0660 /dev/null "${sqlite_file_path}"
  fi
}

# Usage: check_config
# Check everything is ready so switch release. Point Nginx at the new build,
# and run config check. Nginx keeps current settings, regardless of config
# check success/failure
function check_config() {
  # Check versioned PHP_FPM is running
  if ! systemctl is-active "${php_fpm}" &>/dev/null; then
    _exit_1 echo "${php_fpm} is not active"
  fi

  # Check .env exists
  if [[ ! -f ${env_file_path} ]]; then
    _exit_1 echo "${env_file_path} file does not exist"
  fi

  # If the directory Nginx references doesn't exist yet, create it
  if [[ ! -d "${__nginx_root_directories}" ]]; then
    mkdir -p "${__nginx_root_directories}"
  fi

  create_backup "${nginx_reference_file_path}"
  echo "root ${build_root}/public;" > "${nginx_reference_file_path}"

  # Verify Nginx config
  if ! nginx -t; then
    restore_from_backup "${nginx_reference_file_path}"
    _exit_1 echo "Problem with nginx config. Aborting build and reverting Nginx include backup file"
  fi
}

# Usage: switch_release
# 1. Overwrite the symlink the supervisor config looks at; create storage symlink; copy .env
# 2. Wind down supervisor queue workers; clear caches
# 3. Switch release for Nginx and FPM
# 4. Wind up supervisor queue workers; set caches
# 5. Mark release as a success
function switch_release() {
  echo "Switching release"
  create_backup "${current_symlink}"
  ln -snf "${build_root}" "${current_symlink}"
  ln -snf "${build_root}/storage/app/public" "${build_root}/public/storage" # php artisan storage:link

  # Copy .env to build directory
  install -o www-data -g "${__project_name}" -m 0400 "${env_file_path}" "${build_root}/.env"

  # Wind down
  supervisorctl stop "${__project_name}-${environment_name}-worker:"
  /usr/bin/php "${build_root}/artisan" optimize:clear

  # Switch
  service nginx reload
  service "${php_fpm}" reload

  # Wind up
  supervisorctl start "${__project_name}-${environment_name}-worker:"
  /usr/bin/php "${build_root}/artisan" optimize
  # config:cache  => bootstrap/cache/config.php       root:root 644
  # event:cache   => bootstrap/cache/configs.php      root:root 644
  # route:cache   => bootstrap/cache/routes-v7.php    root:root 644
  # view:cache    => storage/framework/views/.        root:root 644
  #               => bootstrap/cache/packages.php     root:root 755
  #               => bootstrap/cache/services.php     root:root 755

  # Mark as successful release
  echo "${build_number}" > "${build_root}/.success"
}

# Usage: delete_failed_releases <releases-root>
# Delete any directories that don't contain '.success' file
function delete_failed_releases() {
  local root="${1:?}"

  while IFS= read -r -d '' release; do
    if [[ ! -f "${release}/.success" ]]; then
      echo "Deleting failed build: ${release}"
      rm -rf "${release}"
    fi
  done < <(find "${root}" -mindepth 1 -maxdepth 1 -type d -print0)
}

# Usage delete_excess_releases <releases_root> <successful_release_to_keep>
# Delete older builds that aren't needed any more
function delete_excess_releases() {
  local root="${1:?}"
  local count="${2:?}"

  if [[ "${count}" -gt 0 ]] \
    && [[ "$(find "${root}" -mindepth 1 -maxdepth 1 -type d | wc -l)" -gt "${count}" ]]
  then
    echo "Deleting excess old builds:"
    find "${root}" -mindepth 1 -maxdepth 1 -type d | sort --version-sort \
      | head --lines "-${count}"
    find "${root}" -mindepth 1 -maxdepth 1 -type d | sort --version-sort \
      | head --lines "-${count}" | xargs rm -fr
  fi
}

# Usage: finish_up
# Delete failed releases; delete old releases in excess of <SUCCESSFUL_RELEASES_TO_KEEP>;
# delete files backed up during release switch process
function finish_up() {
  echo "Build switch successfully. Finishing up"

  delete_failed_releases "${releases_root}"
  delete_excess_releases "${releases_root}" "${successful_releases_to_keep}"
  purge_backup "${nginx_reference_file_path}"
  purge_backup "${current_symlink}"
}

###############################################################################
# Main
###############################################################################

# Usage: _main [<options>] [<arguments>]
# Entry point for the program, handling basic option parsing and dispatching
function _main() {
  _enable_strict_mode
  _validate_commands "/usr/bin/php"
  _split_options "${@}"
  _parse_common_options "${_args[@]}"
  _parse_script_specific_options "${_args[@]}"
  _validate_positional_arguments "${_args[@]}"

  set_global_variables
  set_release_permissions
  check_config
  switch_release
  finish_up

  echo "Deployment script completed!"
}

# Only execute if not sourced in another script (e.g. unit testing)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  _main "${@}"
fi
